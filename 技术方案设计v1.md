# 技术方案设计 (Technical Design) - Claude Code CLI Python 实现

**版本**: 1.3
**日期**: 2026-02-09
**语言**: Python 3.10+

---

## 1. 技术选型 (Technology Stack)

基于“轻量级、原生控制、高可扩展”的原则，我们选择以下 Python 生态中成熟且高效的库：

*   **核心运行时**: Python 3.10+ (利用 Type Hints, Pattern Matching, AsyncIO)
*   **终端交互 (TUI)**:
    *   `prompt_toolkit`: 实现强大的 REPL（自动补全、多行输入、历史记录）。
    *   `rich`: 实现精美的 Markdown 渲染、语法高亮、Panel 面板展示。
*   **LLM 交互**:
    *   `openai`: 使用 OpenAI 兼容的 SDK 连接 Qwen (通义千问) 等模型。虽然最终目标是 Anthropic，但 MVP 阶段支持兼容 OpenAI 接口的模型（如 Qwen, DeepSeek）。
*   **数据校验与配置**:
    *   `pydantic`: 核心数据模型定义。强制使用 Pydantic 定义所有 Configuration 和 Tool Schema，确保类型安全和自动校验。
    *   `pydantic-settings`: 专业的环境变量与配置文件加载库。
*   **依赖注入与模块化**:
    *   采用 **Dependency Injection (DI)** 模式（轻量级实现或 `python-dependency-injector`），确保模块解耦，便于单元测试 (Mocking)。
*   **搜索与文件**:
    *   `Grep` (Python 实现): 纯 Python 实现的高性能正则搜索，无二进制依赖。
    *   `pathlib`: 现代化的文件路径操作。
*   **并发模型**:
    *   **全异步架构**: 核心 Agent Loop、ToolExecutor 及 Sub-agent 均基于 `asyncio` 实现，确保递归调用时的事件循环畅通。
*   **测试框架**:
    *   `pytest`: 单元测试与集成测试。
    *   `pytest-asyncio`: 异步测试支持。

---

## 2. 开发规范与约束 (Development Standards)

**至关重要：所有代码必须遵守以下规范，以确保可维护性和可扩展性。**

1.  **严格的模块化与解耦 (Modularization)**:
    *   禁止循环依赖。
    *   核心业务逻辑 (`core/`) 不应直接依赖具体的 UI 实现 (`cli/`)。
    *   使用 Interface/Protocol 定义模块边界，便于 Mock 测试。
2.  **配置化驱动 (Configuration Driven)**:
    *   所有的策略（Permission Policy）、Prompt 模板、工具列表都应通过配置文件或配置类管理，禁止硬编码。
3.  **统一且详尽的注释 (Documentation & Comments)**:
    *   **Docstrings**: 所有 Class 和 Public Method 必须包含 Google Style Docstring (Args, Returns, Raises)。
    *   **Type Hints**: 100% 的类型注解覆盖率。
    *   **Inline Comments**: 复杂逻辑块必须包含行内注释解释 "Why"，而不仅仅是 "What"。
4.  **可扩展性设计 (Extensibility)**:
    *   工具系统采用**插件化注册机制**。新增工具只需编写一个 Class/Function 并添加装饰器，无需修改核心调度代码。
    *   Hook 系统允许第三方插件注入逻辑。

---

## 3. 工具系统全集 (Tool Ecosystem)

根据需求文档，系统内置以下工具类：

### 3.1 文件操作 (File Operation Tools)
*   `Read`: 读取文件内容或目录列表。支持 PDF 页码范围。大文件自动引用。
*   `Write`: 创建或覆盖文件。遵循 umask。
*   `Edit`: 基于行的文本编辑。支持 Diff 预览。
*   `Glob`: 文件模式匹配。

### 3.2 代码智能 (Code Intelligence Tools)
*   `Grep`: 基于 Python 的正则搜索。包含超时处理和输出截断。
*   `LSP`: (Advanced) 语言服务器协议集成（跳转定义、查找引用）。

### 3.3 执行工具 (Execution Tools)
*   `Bash`: 执行 Shell 命令。支持超时、截断、权限拦截。

### 3.4 代理管理 (Agent Management Tools)
*   `Task`: 创建后台子代理 (Sub-agent)。
    *   **Args**: `goal` (str), `resources` (List[str], optional), `hints` (str, optional)
*   `TaskUpdate`: 汇报进度。
*   `TaskOutput`: 交付最终结果。
*   `TaskStop`: 停止运行中的任务。

### 3.4 任务管理 (Task Management) - 待详细设计
仅在 `plan_mode=True` 时启用。负责维护任务状态图 (DAG)。

```python
class TaskManager:
    def __init__(self):
        self.tasks: Dict[str, Task] = {}
        
    def add_task(self, description: str, dependencies: List[str]) -> str:
        """注册新任务"""
        pass
        
    def update_status(self, task_id: str, status: str, result: str = ""):
        """更新状态：PENDING -> IN_PROGRESS -> COMPLETED/FAILED"""
        pass
        
    def get_next_task(self) -> Optional[Task]:
        """获取下一个可执行任务"""
        pass
```

### 3.5 网络访问 (Web Access Tools)
*   `WebSearch`: 联网搜索。
*   `WebFetch`: 获取网页内容。

---

## 4. 项目目录结构 (Project Structure)

```text
codeagent/
├── codeagent/
│   ├── __init__.py
│   ├── main.py              # 程序入口
│   ├── config.py            # 配置加载 (Env, YAML)
│   │
│   ├── cli/                 # 终端交互层
│   │   ├── repl.py          # REPL 循环 (prompt_toolkit)
│   │   ├── renderer.py      # 渲染器 (rich)
│   │   └── style.py         # 样式定义
│   │
│   ├── core/                # 核心逻辑层
│   │   ├── agent.py         # Agent 类 (Think-Act Loop)
│   │   ├── session.py       # Session 管理 (Context, History)
│   │   ├── llm.py           # LLM 客户端封装
│   │   └── memory.py        # 简单的记忆/摘要管理
│   │
│   ├── tools/               # 工具层
│   │   ├── base.py          # 工具基类 (Decorator)
│   │   ├── registry.py      # 工具注册表
│   │   ├── file_tools.py    # Read, Write, Glob
│   │   ├── search_tools.py  # Grep, LS
│   │   ├── shell_tools.py   # Bash (Subprocess)
│   │   └── agent_tools.py   # Task (Sub-agent creator)
│   │
│   └── commands/            # Slash 命令层
│       ├── dispatcher.py    # 命令分发器
│       └── handlers.py      # /help, /clear 实现
│
├── tests/                   # 单元测试
├── requirements.txt         # 依赖列表
└── README.md
```

---

## 3. 核心类设计 (Core Class Design)

### 3.1 Agent 类 (核心大脑)
实现递归的 Think-Act 循环、子代理栈式调用、任务规划模式 (Plan Mode) 及上下文压缩。

```python
class Agent:
    def __init__(self, session: Session, parent: Optional['Agent'] = None, plan_mode: bool = False):
        self.session = session
        self.parent = parent
        self.plan_mode = plan_mode # 新增：规划模式开关
        self.tools = ToolRegistry.get_tools() # 获取可用工具
        self.task_manager = TaskManager() if plan_mode else None # 新增：任务管理器

    async def run(self, input_text: str, context_summary: Optional[str] = None) -> str:
        """主执行循环"""
        # 0. 上下文预处理 (Smart Extract)
        resolved_context = await self.session.resolve_reference(input_text)
        if resolved_context:
            input_text += f"\n\n{resolved_context}"

        self.session.add_user_message(input_text)
        if context_summary:
             self.session.inject_context(context_summary) # 新增：注入父代理传递的上下文
        
        while True:
            # 1. 上下文监控与压缩 (新增)
            if self.session.token_usage_ratio() > 0.9:
                 await self.session.compress_context(self.llm)

            # 2. 调用 LLM
            response = await self.llm.chat(self.session.messages)
            
            # 2. 处理文本响应
            if response.text:
                yield response.text  # 流式输出给 CLI
            
            # 3. 处理工具调用 (Stop Condition)
            if not response.tool_calls:
                break
                
            # 4. 执行工具
            for tool_call in response.tool_calls:
                if tool_call.name == "Task":
                    # === 关键：栈式递归创建子代理 ===
                    # 优化：传递 context_summary
                    summary = await self.session.summarize_relevant_context()
                    # 约束：Sub-agent 默认关闭 plan_mode，专注于单一任务执行
                    sub_agent = Agent(session=Session.create_child(), parent=self, plan_mode=False)
                    result = await sub_agent.run(tool_call.args['goal'], context_summary=summary)
                elif tool_call.name == "UpdateTask" and self.plan_mode:
                    # 新增：任务状态更新
                    self.task_manager.update_status(tool_call.args)
                    result = "Task status updated."
                else:
                    # 工具执行 (全异步)
                    result = await ToolExecutor.execute(tool_call)
                
                # 5. 结果回填 Context
                self.session.add_tool_result(tool_call.id, result)
```

### 3.2 Tool 装饰器与注册表
使用 Pydantic 简化工具定义，自动生成给 LLM 的 Schema。

```python
# tools/base.py
from pydantic import BaseModel, Field

class ToolInput(BaseModel):
    path: str = Field(..., description="File path to read")

@tool(name="read_file", description="Read file content")
def read_file(args: ToolInput) -> str:
    # ... implementation
    pass
```

### 3.3 Session 与 Context 管理
负责 Token 计数与压缩。

```python
class Session:
    def __init__(self):
        self.messages: List[Message] = []
        self.max_tokens = 200000 # Claude 3.5 Sonnet context
        self.reserved_output_tokens = 8192 # 预留输出空间
        self.compression_boundary: int = 0 # 压缩边界索引
    
    @property
    def effective_window(self) -> int:
        return self.max_tokens - self.reserved_output_tokens

    def token_usage_ratio(self) -> float:
        current = self._count_tokens()
        return current / self.effective_window

    def add_message(self, msg):
        self.messages.append(msg)
        # Token 监控由 Agent 主循环触发，这里仅做存储
        
    async def resolve_reference(self, input_text: str) -> str:
        """
        解析 @file:ref 引用。
        1. 提取 keyword。
        2. Glob 搜索匹配文件。
        3. 自动 Read 文件内容并返回 Context 字符串。
        """
        pass
            
    async def compress_context(self, llm_client: LLMClient):
        """
        压缩策略：
        1. 保留 System Prompt (index 0)
        2. 保留最近 N 轮交互 (e.g., last 10 messages)
        3. 将中间部分 (boundary -> len-N) 发送给 LLM 生成 Summary
        4. 替换中间部分为单个 SummaryMessage
        """
        # ... implementation
        pass

    async def summarize_relevant_context(self) -> str:
        """为子代理生成上下文摘要"""
        pass
```

---

## 4. 关键流程详解 (Key Flows)

### 4.1 权限拦截流程 (Permission Flow)
在 `ToolExecutor.execute` 中实现拦截：

1.  **解析**: 获取 Tool 名称和参数。
2.  **查表**: 检查 `PERMISSION_POLICY`。
    *   `read_file` -> `ALLOW`
    *   `bash` -> `CONFIRM`
3.  **交互**:
    *   如果是 `CONFIRM`，调用 `cli.confirm(f"Execute {cmd}?")`。
    *   用户输入 `y` -> 继续执行。
    *   用户输入 `n` -> 抛出 `PermissionError`，LLM 接收错误信息。

### 4.2 统一 Shell 执行器 (Unified Shell Executor)
为了统一管理 Shell 执行权限和逻辑，系统提供底层的 `ShellExecutor` 类。

```python
# core/shell.py
class ShellExecutor:
    @staticmethod
    def run(command: str, timeout: int = 60) -> CommandResult:
        """
        Executes a shell command.
        Auto-detects shell (PowerShell on Win, Bash on *nix).
        """
        # 1. 黑名单检查
        if is_dangerous(command):
            raise SecurityError("Command blocked")
            
        # 2. 平台检测
        shell = "powershell" if os.name == 'nt' else "/bin/bash"
        
        # 3. 执行 (subprocess)
        # ... implementation
        pass

# Usage 1: Internal (Context Gathering)
files = ShellExecutor.run("dir *.py /s /b").stdout.splitlines()

# Usage 2: LLM Tool
@tool
def run_shell(command: str):
    return ShellExecutor.run(command).output
```

### 4.3 宿主机 Shell 执行工具
`run_bash` (或 `run_shell`) 是 `ShellExecutor` 的 LLM 包装器。

---

## 5. 开发计划 (Development Plan)

### 第一阶段：骨架搭建 (Skeleton)
1.  初始化 Python 项目结构。
2.  实现 `cli/repl.py`，跑通基本的 REPL 循环。
3.  实现 `config.py`，加载 API Key。

### 第二阶段：Agent 与 LLM 核心 (Core)
1.  封装 `core/llm.py`，调通 Anthropic API。
2.  实现 `core/agent.py` 的基础循环（暂不支持 Tool）。
3.  实现 `core/session.py` 的消息管理。

### 第三阶段：工具系统 (Tools)
1.  实现 `tools/registry.py` 和装饰器机制。
2.  实现基础文件工具 (`read`, `write`, `ls`)。
3.  实现 `core/agent.py` 的工具调用处理逻辑。
4.  集成 `rich` 渲染工具输出。

### 第四阶段：高级特性 (Advanced)
1.  实现 `grep`, `glob` 搜索工具。
2.  实现 `bash` 工具及权限拦截逻辑。
3.  实现 `Task` 工具（子代理递归）。

---

## 6. 待确认事项
*   **LLM Model**: 默认使用 `claude-3-5-sonnet-20241022`。
*   **API Key**: 需用户在 `.env` 中提供 `ANTHROPIC_API_KEY`。
